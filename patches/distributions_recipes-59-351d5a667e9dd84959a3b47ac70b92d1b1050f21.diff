diff --git a/core/core.services.yml b/core/core.services.yml
index 482f3c3daa95fa2981889ff90c99aba824c7b376..bca12582f7499963c6964aad9348411d2f8f9da5 100644
--- a/core/core.services.yml
+++ b/core/core.services.yml
@@ -364,6 +364,14 @@ services:
     public: false
     tags:
       - { name: backend_overridable }
+  config.storage.checkpoint:
+    class: Drupal\Core\Config\Checkpoint\CheckpointStorage
+    arguments: [ '@config.storage', '@config.checkpoints', '@keyvalue' ]
+    tags:
+      - { name: event_subscriber }
+  config.checkpoints:
+    class: Drupal\Core\Config\Checkpoint\Checkpoints
+    arguments: [ '@state', '@datetime.time' ]
   config.import_transformer:
     class: Drupal\Core\Config\ImportStorageTransformer
     arguments: ['@event_dispatcher', '@database', '@lock', '@lock.persistent']
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php
new file mode 100644
index 0000000000000000000000000000000000000000..122d146bb10bc4d8c6c0b54aedd21647cfe472e9
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoint.php
@@ -0,0 +1,30 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * A value object to store information about a checkpoint.
+ */
+final class Checkpoint {
+
+  /**
+   * Constructs a checkpoint object.
+   *
+   * @param string $id
+   *   The checkpoint's ID.
+   * @param \Stringable|string $label
+   *   The human-readable label.
+   * @param int $timestamp
+   *   The checkpoint's timestamp
+   * @param string|null $parent
+   *   The ID of the checkpoint's parent.
+   */
+  public function __construct(
+    public readonly string $id,
+    public readonly \Stringable|string $label,
+    public readonly int $timestamp,
+    public readonly ?string $parent,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php
new file mode 100644
index 0000000000000000000000000000000000000000..4616ad4636a1b3daad0ed33c8cc58794918183f6
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointExistsException.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when trying to add a checkpoint with an ID that already exists.
+ */
+class CheckpointExistsException extends \RuntimeException {
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotActiveException.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotActiveException.php
new file mode 100644
index 0000000000000000000000000000000000000000..a3f2a6ad71d0857bb6ecc1402f864c48d68eb373
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotActiveException.php
@@ -0,0 +1,12 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when using the checkpoint storage with no checkpoints.
+ */
+class CheckpointNotActiveException extends \RuntimeException {
+
+  protected $message = 'If there are no checkpoints then reading from this storage is an error.';
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotExistsException.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotExistsException.php
new file mode 100644
index 0000000000000000000000000000000000000000..a01a78ef298e985502505b6a9587a75b1d70cc44
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointNotExistsException.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+/**
+ * Thrown when trying to set a revert checkpoint that does not exist.
+ */
+class CheckpointNotExistsException extends \RuntimeException {
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php
new file mode 100644
index 0000000000000000000000000000000000000000..94c6076a475ce89a101ad841536736ddd869fb06
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorage.php
@@ -0,0 +1,406 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Config\ConfigCrudEvent;
+use Drupal\Core\Config\ConfigEvents;
+use Drupal\Core\Config\ConfigRenameEvent;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\KeyValueStore\KeyValueFactoryInterface;
+use Drupal\Core\KeyValueStore\KeyValueStoreInterface;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+
+/**
+ * Provides a config storage that can make checkpoints.
+ *
+ * This storage wraps another storage, typically the active storage, and
+ * provides the ability to take checkpoints. Once a checkpoint has been created
+ * all configuration operations made after the checkpoint will be recorded, so
+ * it is possible to revert to original state when the checkpoint was taken.
+ */
+final class CheckpointStorage implements CheckpointStorageInterface, EventSubscriberInterface {
+
+  /**
+   * Used as prefix to a config checkpoint collection.
+   */
+  private const KEY_VALUE_COLLECTION_PREFIX = 'config.checkpoint.';
+
+  /**
+   * Used to store the list of collections in each checkpoint.
+   *
+   * Note this cannot be a valid configuration name.
+   *
+   * @see \Drupal\Core\Config\ConfigBase::validateName()
+   */
+  private const CONFIG_COLLECTION_KEY = 'collections';
+
+  /**
+   * @var \Drupal\Core\KeyValueStore\KeyValueStoreInterface[]
+   */
+  private array $keyValues;
+
+  public function __construct(
+    private readonly StorageInterface $activeStorage,
+    private readonly Checkpoints $checkpoints,
+    private readonly KeyValueFactoryInterface $keyValueFactory,
+    private readonly string $collection = StorageInterface::DEFAULT_COLLECTION
+  ) {
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exists($name) {
+    if (count($this->checkpoints) === 0) {
+      throw new CheckpointNotActiveException();
+    }
+
+    foreach ($this->checkpoints->getCheckpointsToReadFrom() as $checkpoint) {
+      $in_checkpoint = $this->getKeyValue($checkpoint->id, $this->collection)->get($name);
+      if ($in_checkpoint !== NULL) {
+        // If $in_checkpoint is FALSE then the configuration has been deleted.
+        return $in_checkpoint !== FALSE;
+      }
+    }
+    return $this->activeStorage->exists($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($name) {
+    if (count($this->checkpoints) === 0) {
+      throw new CheckpointNotActiveException();
+    }
+
+    $return = $this->readMultiple([$name]);
+    return $return[$name] ?? FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readMultiple(array $names) {
+    if (count($this->checkpoints) === 0) {
+      throw new CheckpointNotActiveException();
+    }
+    $return = [];
+
+    foreach ($this->checkpoints->getCheckpointsToReadFrom() as $checkpoint) {
+      $return = array_merge(
+        $return,
+        $this->getKeyValue($checkpoint->id, $this->collection)->getMultiple($names)
+      );
+      // Remove the read names from the list to fetch.
+      $names = array_diff($names, array_keys($return));
+      if (empty($names)) {
+        // All the configuration has been read. Nothing more to do.
+        break;
+      }
+    }
+
+    // Names not found in the checkpoints have not been modified: read from
+    // active storage.
+    if (!empty($names)) {
+      $return = array_merge(
+        $return,
+        $this->activeStorage->readMultiple($names)
+      );
+    }
+
+    // Remove any renamed or new configuration (FALSE has been recorded for
+    // these operations in the checkpoint).
+    // @see ::onConfigRename()
+    // @see ::onConfigSaveAndDelete()
+    return array_filter($return);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function encode($data) {
+    return $this->activeStorage->encode($data);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function decode($raw) {
+    return $this->activeStorage->decode($raw);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listAll($prefix = '') {
+    if (count($this->checkpoints) === 0) {
+      throw new CheckpointNotActiveException();
+    }
+
+    $names = $new_configuration = [];
+
+    foreach ($this->checkpoints->getCheckpointsToReadFrom() as $checkpoint) {
+      $checkpoint_names = array_keys(array_filter($this->getKeyValue($checkpoint->id, $this->collection)->getAll(), function (mixed $value, string $name) use (&$new_configuration, $prefix) {
+        if ($name === static::CONFIG_COLLECTION_KEY) {
+          return FALSE;
+        }
+        // Remove any that don't start with the prefix.
+        if ($prefix !== '' && !str_starts_with($name, $prefix)) {
+          return FALSE;
+        }
+        // We've determined in a previous checkpoint that the configuration did
+        // not exist.
+        if (in_array($name, $new_configuration, TRUE)) {
+          return FALSE;
+        }
+        // If the value is FALSE then the configuration was created after the
+        // checkpoint.
+        if ($value === FALSE) {
+          $new_configuration[] = $name;
+          return FALSE;
+        }
+        return TRUE;
+      }, ARRAY_FILTER_USE_BOTH));
+      $names = array_merge($names, $checkpoint_names);
+    }
+
+    // Remove any names that did not exist prior to the checkpoint.
+    $active_names = array_diff($this->activeStorage->listAll($prefix), $new_configuration);
+
+    $names = array_unique(array_merge($names, $active_names));
+    sort($names);
+    return $names;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createCollection($collection) {
+    return new self(
+      $this->activeStorage->createCollection($collection),
+      $this->checkpoints,
+      $this->keyValueFactory,
+      $collection
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAllCollectionNames() {
+    $names = [];
+    foreach ($this->checkpoints->getCheckpointsToReadFrom() as $checkpoint) {
+      $names = array_merge(
+        $names,
+        $this->getKeyValue($checkpoint->id, StorageInterface::DEFAULT_COLLECTION)->get(static::CONFIG_COLLECTION_KEY, [])
+      );
+    }
+    return array_unique(array_merge($this->activeStorage->getAllCollectionNames(), $names));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCollectionName() {
+    return $this->collection;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function checkpoint(string|\Stringable $label): Checkpoint {
+    // Generate a new ID based on the state of the current active checkpoint.
+    $active_checkpoint = $this->checkpoints->getActiveCheckpoint();
+    if ($active_checkpoint instanceof Checkpoint) {
+      $collections = $this->getAllCollectionNames();
+      $collections[] = StorageInterface::DEFAULT_COLLECTION;
+      foreach ($collections as $collection) {
+        $current_checkpoint_data[$collection] = $this->getKeyValue($active_checkpoint->id, $collection)->getAll();
+        // Remove the collections key because it is irrelevant.
+        unset($current_checkpoint_data[$collection][static::CONFIG_COLLECTION_KEY]);
+        // If there is no data in the collection then there is no need to hash
+        // the empty array.
+        if (empty($current_checkpoint_data[$collection])) {
+          unset($current_checkpoint_data[$collection]);
+        }
+      }
+
+      if (!empty($current_checkpoint_data)) {
+        $id = hash('sha1', ($active_checkpoint->parent ?? '') . json_encode($current_checkpoint_data));
+        $active_checkpoint = $this->checkpoints->add($id, $label);
+      }
+      else {
+        // @todo Should this be an error - like git when you try to commit an
+        //   empty changeset.
+      }
+    }
+    else {
+      // How awesome would it be to have a hash the represents the entire config
+      // storage. For now generate a random hash.
+      $id = hash('sha1', Crypt::randomBytesBase64());
+      $active_checkpoint = $this->checkpoints->add($id, $label);
+    }
+
+    return $active_checkpoint;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setReadFromCheckpoint(string|Checkpoint $checkpoint): static {
+    $this->checkpoints->setReadFromCheckpoint($checkpoint);
+    return $this;
+  }
+
+  /**
+   * Gets the key value storage for the provided checkpoint.
+   *
+   * @param string $checkpoint
+   *   The checkpoint to get the key value storage for.
+   * @param string $collection
+   *   The config collection to get the key value storage for.
+   *
+   * @return \Drupal\Core\KeyValueStore\KeyValueStoreInterface
+   *   The key value storage for the provided checkpoint.
+   */
+  private function getKeyValue(string $checkpoint, string $collection): KeyValueStoreInterface {
+    $checkpoint_key = $checkpoint;
+    if ($collection !== StorageInterface::DEFAULT_COLLECTION) {
+      $checkpoint_key = $collection . '.' . $checkpoint_key;
+    }
+    if (!isset($this->keyValues[$checkpoint_key])) {
+      $this->keyValues[$checkpoint_key] = $this->keyValueFactory->get(self::KEY_VALUE_COLLECTION_PREFIX . $checkpoint_key);
+    }
+    return $this->keyValues[$checkpoint_key];
+  }
+
+  /**
+   * Updates checkpoint when configuration is saved.
+   *
+   * @param \Drupal\Core\Config\ConfigCrudEvent $event
+   *   The configuration event.
+   */
+  public function onConfigSaveAndDelete(ConfigCrudEvent $event): void {
+    if (count($this->checkpoints) === 0) {
+      return;
+    }
+
+    $saved_config = $event->getConfig();
+    $collection = $saved_config->getStorage()->getCollectionName();
+    $this->storeCollectionName($collection);
+
+    $active_checkpoint = $this->getKeyValue($this->checkpoints->getActiveCheckpoint()->id, $collection);
+    $in_checkpoint = $active_checkpoint->get($saved_config->getName());
+
+    // If we have not yet stored a checkpoint for this configuration we should.
+    if ($in_checkpoint === NULL) {
+      $original_data = $saved_config->getOriginal(apply_overrides: FALSE);
+      // An empty array indicates that the config has to be new as a sequence
+      // cannot be the root of a config object. We need to make this assumption
+      // because $saved_config->isNew() will always return FALSE here.
+      if (empty($original_data)) {
+        $original_data = FALSE;
+      }
+      // Only save change to state if there is a change.
+      if ($original_data !== $saved_config->getRawData()) {
+        $active_checkpoint->set($saved_config->getName(), $original_data);
+      }
+    }
+  }
+
+  /**
+   * Updates checkpoint when configuration is saved.
+   *
+   * @param \Drupal\Core\Config\ConfigRenameEvent $event
+   *   The configuration event.
+   */
+  public function onConfigRename(ConfigRenameEvent $event): void {
+    if (count($this->checkpoints) === 0) {
+      return;
+    }
+    $collection = $event->getConfig()->getStorage()->getCollectionName();
+    $this->storeCollectionName($collection);
+
+    $active_checkpoint = $this->getKeyValue($this->checkpoints->getActiveCheckpoint()->id, $event->getConfig()->getStorage()->getCollectionName());
+
+    $old_name = $event->getOldName();
+    $in_checkpoint = $active_checkpoint->get($old_name);
+
+    // If we have not yet stored a checkpoint for this configuration we should.
+    if ($in_checkpoint === NULL) {
+      $active_checkpoint->set($old_name, $event->getConfig()->getOriginal(apply_overrides: FALSE));
+    }
+
+    // Record that the new name did not exist prior to the checkpoint.
+    $new_name = $event->getConfig()->getName();
+    $in_checkpoint = $active_checkpoint->get($new_name);
+    if ($in_checkpoint === NULL) {
+      $active_checkpoint->set($new_name, FALSE);
+    }
+  }
+
+  /**
+   * Stores the collection name so the storage knows its own collections.
+   *
+   * @param string $collection
+   *   The collection to store.
+   *
+   * @return void
+   */
+  private function storeCollectionName(string $collection) {
+    // We do not need to store the default collection.
+    if ($collection === StorageInterface::DEFAULT_COLLECTION) {
+      return;
+    }
+
+    if (in_array($collection, $this->getAllCollectionNames(), TRUE)) {
+      return;
+    }
+
+    $key_value = $this->getKeyValue($this->checkpoints->getActiveCheckpoint()->id, StorageInterface::DEFAULT_COLLECTION);
+    $collections = $key_value->get(static::CONFIG_COLLECTION_KEY, []);
+    assert(is_array($collections));
+    $collections[] = $collection;
+    $key_value->set(static::CONFIG_COLLECTION_KEY, array_unique($collections));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getSubscribedEvents(): array {
+    $events[ConfigEvents::SAVE][] = 'onConfigSaveAndDelete';
+    $events[ConfigEvents::DELETE][] = 'onConfigSaveAndDelete';
+    $events[ConfigEvents::RENAME][] = 'onConfigRename';
+    return $events;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($name, array $data) {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($name) {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($name, $new_name) {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteAll($prefix = '') {
+    throw new \BadMethodCallException(__METHOD__ . ' is not allowed on a CheckpointStorage');
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php
new file mode 100644
index 0000000000000000000000000000000000000000..3b484c2fdb2d6e0778becb379dd31fa8f627c105
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/CheckpointStorageInterface.php
@@ -0,0 +1,35 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Core\Config\StorageInterface;
+
+/**
+ * Provides an interface for checkpoint storages.
+ */
+interface CheckpointStorageInterface extends StorageInterface {
+
+  /**
+   * Creates a checkpoint, if required.
+   *
+   * @param string|\Stringable $label
+   *   The checkpoint label.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint
+   *   The currently active checkpoint.
+   */
+  public function checkpoint(string|\Stringable $label): Checkpoint;
+
+  /**
+   * Sets the checkpoint to read from.
+   *
+   * @param string $checkpoint
+   *   The checkpoint to read from.
+   *
+   * @return $this
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\CheckpointNotExistsException
+   */
+  public function setReadFromCheckpoint(string $checkpoint): static;
+
+}
diff --git a/core/lib/Drupal/Core/Config/Checkpoint/Checkpoints.php b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoints.php
new file mode 100644
index 0000000000000000000000000000000000000000..78e8460fc9134f3ed6d6642a0224ae723fdc51cb
--- /dev/null
+++ b/core/lib/Drupal/Core/Config/Checkpoint/Checkpoints.php
@@ -0,0 +1,192 @@
+<?php
+
+namespace Drupal\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Core\State\StateInterface;
+
+/**
+ * A list of Checkpoint objects.
+ *
+ * Maintains a list of sequential checkpoints, with each building on top of the
+ * previous one.
+ */
+final class Checkpoints implements \IteratorAggregate, \Countable {
+
+  /**
+   * The store of all the checkpoint names in state.
+   */
+  private const CHECKPOINT_KEY = 'config.checkpoints';
+
+  /**
+   * The active checkpoint.
+   *
+   * In our implementation this is always the last in the list.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   */
+  private ?Checkpoint $activeCheckpoint;
+
+  /**
+   * The checkpoint to read from.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   */
+  private ?Checkpoint $readFromCheckpoint;
+
+  /**
+   * The list of checkpoints, keyed by ID.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\Checkpoint[]
+   */
+  private array $checkpoints;
+
+  /**
+   * Constructs a checkpoints object.
+   *
+   * @param \Drupal\Core\State\StateInterface $state
+   *   The state service.
+   * @param \Drupal\Component\Datetime\TimeInterface $time
+   *   The time service.
+   */
+  public function __construct(
+    private readonly StateInterface $state,
+    private readonly TimeInterface $time,
+  ) {
+    $this->checkpoints = $this->state->get(self::CHECKPOINT_KEY, []);
+    $this->readFromCheckpoint = reset($this->checkpoints) ?: NULL;
+    $this->activeCheckpoint = end($this->checkpoints) ?: NULL;
+  }
+
+  /**
+   * Gets the active checkpoint.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint|null
+   *   The active checkpoint or NULL if there are no checkpoints.
+   */
+  public function getActiveCheckpoint(): ?Checkpoint {
+    return $this->activeCheckpoint;
+  }
+
+  /**
+   * Sets the checkpoint to read from.
+   *
+   * @param string|\Drupal\Core\Config\Checkpoint\Checkpoint $checkpoint
+   *   The checkpoint to read from.
+   *
+   * @return $this
+   *
+   * @see \Drupal\Core\Config\Checkpoint\Checkpoints::getCheckpointsToReadFrom()
+   */
+  public function setReadFromCheckpoint(string|Checkpoint $checkpoint): self {
+    if ($checkpoint instanceof Checkpoint) {
+      $checkpoint = $checkpoint->id;
+    }
+    if (!isset($this->checkpoints[$checkpoint])) {
+      throw new CheckpointNotExistsException(sprintf('The checkpoint "%s" does not exist', $checkpoint));
+    }
+    $this->readFromCheckpoint = $this->checkpoints[$checkpoint];
+    return $this;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getIterator(): \Traversable {
+    return new \ArrayIterator($this->checkpoints);
+  }
+
+  /**
+   * Gets the checkpoints to read from.
+   *
+   * @return iterable|null
+   *
+   * @see \Drupal\Core\Config\Checkpoint\Checkpoints::setReadFromCheckpoint()
+   */
+  public function getCheckpointsToReadFrom(): ?iterable {
+    if ($this->readFromCheckpoint === NULL) {
+      return;
+    }
+    $read_checkpoint_found = FALSE;
+    foreach ($this->checkpoints as $checkpoint) {
+      if ($checkpoint->id === $this->readFromCheckpoint->id) {
+        $read_checkpoint_found = TRUE;
+      }
+      if ($read_checkpoint_found) {
+        yield $checkpoint->id => $checkpoint;
+      }
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function count(): int {
+    return count($this->checkpoints);
+  }
+
+  /**
+   * Adds a new checkpoint.
+   *
+   * @param string $id
+   *   The checkpoint hash to add.
+   * @param string|\Stringable $label
+   *   The checkpoint label.
+   *
+   * @return \Drupal\Core\Config\Checkpoint\Checkpoint
+   *   The new checkpoint.
+   *
+   * @throws \Drupal\Core\Config\Checkpoint\CheckpointExistsException
+   *   Thrown when the ID already exists.
+   */
+  public function add(string $id, string|\Stringable $label): Checkpoint {
+    if (isset($this->checkpoints[$id])) {
+      throw new CheckpointExistsException(sprintf('Cannot create a checkpoint with the ID "%s" as it already exists', $id));
+    }
+    $checkpoint = new Checkpoint($id, $label, $this->time->getCurrentTime(), $this->activeCheckpoint?->id);
+    $this->checkpoints[$checkpoint->id] = $checkpoint;
+    $this->activeCheckpoint = $checkpoint;
+    if ($this->readFromCheckpoint === NULL) {
+      $this->readFromCheckpoint = $checkpoint;
+    }
+    $this->state->set(self::CHECKPOINT_KEY, $this->checkpoints);
+
+    return $checkpoint;
+  }
+
+  /**
+   * Deletes checkpoints.
+   *
+   * @param string|null $id
+   *   (optional) The ID of the checkpoint to delete up to. If not provided then
+   *   all checkpoints are deleted.
+   *
+   * @return static
+   */
+  public function delete(string $id = NULL): static {
+    if ($id === NULL) {
+      $this->checkpoints = [];
+      $this->activeCheckpoint = $this->readFromCheckpoint = NULL;
+      $this->state->delete(self::CHECKPOINT_KEY);
+      return $this;
+    }
+
+    if (!isset($this->checkpoints[$id])) {
+      throw new CheckpointNotExistsException(sprintf('Cannot delete a checkpoint with the ID "%s" as it does not exist', $id));
+    }
+
+    foreach ($this->checkpoints as $key => $checkpoint) {
+      unset($this->checkpoints[$key]);
+      if ($checkpoint->id === $id) {
+        break;
+      }
+    }
+    $this->state->set(self::CHECKPOINT_KEY, $this->checkpoints);
+
+    if (!isset($this->checkpoints[$this->readFromCheckpoint->id])) {
+      $this->readFromCheckpoint = reset($this->checkpoints) ?: NULL;
+    }
+    return $this;
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php b/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..2558b2e34ad3b7849d11441668c8dc097f915b03
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Config/Storage/Checkpoint/CheckpointStorageTest.php
@@ -0,0 +1,309 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Config\Storage\Checkpoint;
+
+use Drupal\Core\Config\Checkpoint\CheckpointStorageInterface;
+use Drupal\Core\Config\ConfigImporter;
+use Drupal\Core\Config\StorageComparer;
+use Drupal\KernelTests\KernelTestBase;
+
+/**
+ * Tests CheckpointStorage operations.
+ *
+ * @group config
+ */
+class CheckpointStorageTest extends KernelTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = ['system', 'config_test'];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+    $this->installConfig(['system', 'config_test']);
+  }
+
+  public function testConfigSaveAndRead(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $this->config('system.site')->set('name', 'Test1')->save();
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('system.site')->set('name', 'Test2')->save();
+    usleep(1);
+    $check2 = $checkpoint_storage->checkpoint('B');
+    $this->config('system.site')->set('name', 'Test3')->save();
+
+    $this->assertSame('Test3', $this->config('system.site')->get('name'));
+    $this->assertSame('Test1', $checkpoint_storage->read('system.site')['name']);
+
+    // The config listings should be exactly the same.
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+    $this->assertSame('Test2', $checkpoint_storage->read('system.site')['name']);
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+
+    $checkpoint_storage->setReadFromCheckpoint($check1);
+    $this->assertSame('Test1', $checkpoint_storage->read('system.site')['name']);
+    $this->assertSame($checkpoint_storage->listAll(), $this->container->get('config.storage')->listAll());
+  }
+
+  public function testConfigDelete(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('config_test.system')->delete();
+
+    $this->assertFalse($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll('config_test.'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll('system.'));
+    // Should not be part of the active storage anymore.
+    $this->assertNotContains('config_test.system', $this->container->get('config.storage')->listAll());
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+
+    $checkpoint_storage->setReadFromCheckpoint($check1);
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('bar', $checkpoint_storage->read('config_test.system')['foo']);
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+  }
+
+  public function testConfigCreate(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    $this->config('config_test.system')->delete();
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll('config_test.'));
+    $this->assertContains('system.site', $checkpoint_storage->listAll('system.'));
+    $this->assertContains('config_test.system', $this->container->get('config.storage')->listAll());
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+    $this->config('config_test.system')->delete();
+
+    $this->assertFalse($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $this->config('config_test.system')->set('foo', 'foobar')->save();
+    $this->assertTrue($this->container->get('config.storage')->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+    $this->assertTrue($checkpoint_storage->exists('config_test.system'));
+    $this->assertSame('foobar', $checkpoint_storage->read('config_test.system')['foo']);
+    $this->assertContains('config_test.system', $checkpoint_storage->listAll());
+
+    $checkpoint_storage->setReadFromCheckpoint($check1);
+    $this->assertFalse($checkpoint_storage->exists('config_test.system'));
+    $this->assertFalse($checkpoint_storage->read('config_test.system'));
+    $this->assertNotContains('config_test.system', $checkpoint_storage->listAll());
+  }
+
+  public function testConfigRename(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->container->get('config.factory')->rename('config_test.dynamic.dotted.default', 'config_test.dynamic.renamed');
+    $this->config('config_test.dynamic.renamed')->set('id', 'renamed')->save();
+
+    $this->assertFalse($checkpoint_storage->exists('config_test.dynamic.renamed'));
+    $this->assertTrue($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+    $this->assertSame('dotted.default', $checkpoint_storage->read('config_test.dynamic.dotted.default')['id']);
+    $this->assertSame($checkpoint_storage->read('config_test.dynamic.dotted.default')['uuid'], $this->config('config_test.dynamic.renamed')->get('uuid'));
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+    /** @var \Drupal\Core\Config\Entity\ConfigEntityStorage $storage */
+    $storage = $this->container->get('entity_type.manager')->getStorage('config_test');
+    // Entity1 will be deleted by the test.
+    $entity1 = $storage->create(
+      [
+        'id' => 'dotted.default',
+        'label' => 'Another one',
+      ]
+    );
+    $entity1->save();
+
+    $check3 = $checkpoint_storage->checkpoint('C');
+
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+    $this->assertFalse($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+
+    $checkpoint_storage->setReadFromCheckpoint($check3);
+    $this->assertTrue($checkpoint_storage->exists('config_test.dynamic.dotted.default'));
+    $this->assertNotEquals($checkpoint_storage->read('config_test.dynamic.dotted.default')['uuid'], $this->config('config_test.dynamic.renamed')->get('uuid'));
+    $this->assertSame('Another one', $checkpoint_storage->read('config_test.dynamic.dotted.default')['label']);
+
+    $checkpoint_storage->setReadFromCheckpoint($check1);
+    $this->assertSame('Default', $checkpoint_storage->read('config_test.dynamic.dotted.default')['label']);
+  }
+
+  public function testRevert(): void {
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check1 = $checkpoint_storage->checkpoint('A');
+    $this->assertTrue($this->container->get('module_installer')->uninstall(['config_test']));
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $config_changelist = $importer->getStorageComparer()->createChangelist()->getChangelist();
+    $this->assertContains('config_test.dynamic.dotted.default', $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_test'));
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $config_changelist = $importer->getStorageComparer()->createChangelist()->getChangelist();
+    $this->assertContains('config_test.dynamic.dotted.default', $config_changelist['delete']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame([], $config_changelist['rename']);
+    $importer->import();
+    $this->assertFalse($this->container->get('module_handler')->moduleExists('config_test'));
+
+    $checkpoint_storage->setReadFromCheckpoint($check1);
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $importer->getStorageComparer()->createChangelist();
+    $importer->import();
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_test'));
+  }
+
+  public function testRevertWithCollections(): void {
+    $collections = [
+      'another_collection',
+      'collection.test1',
+      'collection.test2',
+    ];
+    // Set the event listener to return three possible collections.
+    // @see \Drupal\config_collection_install_test\EventSubscriber
+    \Drupal::state()->set('config_collection_install_test.collection_names', $collections);
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    $checkpoint_storage->checkpoint('A');
+
+    // Install the test module.
+    $this->assertTrue($this->container->get('module_installer')->install(['config_collection_install_test']));
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEquals($collections, $active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $data = $collection_storage->read('config_collection_install_test.test');
+      $this->assertEquals($collection, $data['collection']);
+    }
+
+    $check2 = $checkpoint_storage->checkpoint('B');
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+    $storage_comparer = $importer->getStorageComparer();
+    $config_changelist = $storage_comparer->createChangelist()->getChangelist();
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+    foreach ($collections as $collection) {
+      $config_changelist = $storage_comparer->getChangelist(NULL, $collection);
+      $this->assertSame([], $config_changelist['create']);
+      $this->assertSame([], $config_changelist['update']);
+      $this->assertSame(['config_collection_install_test.test'], $config_changelist['delete'], $collection);
+      $this->assertSame([], $config_changelist['rename']);
+    }
+
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $checkpoint_storage = $this->container->get('config.storage.checkpoint');
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEmpty($active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $this->assertFalse($collection_storage->read('config_collection_install_test.test'));
+    }
+
+    $checkpoint_storage->setReadFromCheckpoint($check2);
+
+    $importer = $this->getConfigImporter($checkpoint_storage);
+
+    $storage_comparer = $importer->getStorageComparer();
+    $config_changelist = $storage_comparer->createChangelist()->getChangelist();
+    $this->assertSame([], $config_changelist['create']);
+    $this->assertSame(['core.extension'], $config_changelist['update']);
+    $this->assertSame([], $config_changelist['delete']);
+    $this->assertSame([], $config_changelist['rename']);
+    foreach ($collections as $collection) {
+      $config_changelist = $storage_comparer->getChangelist(NULL, $collection);
+      $this->assertSame(['config_collection_install_test.test'], $config_changelist['create']);
+      $this->assertSame([], $config_changelist['update']);
+      $this->assertSame([], $config_changelist['delete'], $collection);
+      $this->assertSame([], $config_changelist['rename']);
+    }
+    $importer->import();
+    $this->assertSame([], $importer->getErrors());
+
+    $this->assertTrue($this->container->get('module_handler')->moduleExists('config_collection_install_test'));
+    /** @var \Drupal\Core\Config\StorageInterface $active_storage */
+    $active_storage = \Drupal::service('config.storage');
+    $this->assertEquals($collections, $active_storage->getAllCollectionNames());
+    foreach ($collections as $collection) {
+      $collection_storage = $active_storage->createCollection($collection);
+      $data = $collection_storage->read('config_collection_install_test.test');
+      $this->assertEquals($collection, $data['collection']);
+    }
+  }
+
+  private function getConfigImporter(CheckpointStorageInterface $storage): ConfigImporter {
+    $storage_comparer = new StorageComparer(
+      $storage,
+      $this->container->get('config.storage')
+    );
+    return new ConfigImporter(
+      $storage_comparer,
+      $this->container->get('event_dispatcher'),
+      $this->container->get('config.manager'),
+      $this->container->get('lock'),
+      $this->container->get('config.typed'),
+      $this->container->get('module_handler'),
+      $this->container->get('module_installer'),
+      $this->container->get('theme_handler'),
+      $this->container->get('string_translation'),
+      $this->container->get('extension.list.module'),
+      $this->container->get('extension.list.theme')
+    );
+  }
+
+}
diff --git a/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..f7c133477afc3e4da93aebabe68471c996ecd589
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointStorageTest.php
@@ -0,0 +1,266 @@
+<?php
+
+namespace Drupal\Tests\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\Time;
+use Drupal\Core\Config\Checkpoint\Checkpoint;
+use Drupal\Core\Config\Checkpoint\Checkpoints;
+use Drupal\Core\Config\Checkpoint\CheckpointStorage;
+use Drupal\Core\Config\Config;
+use Drupal\Core\Config\ConfigCrudEvent;
+use Drupal\Core\Config\MemoryStorage;
+use Drupal\Core\Config\StorageCopyTrait;
+use Drupal\Core\Config\StorageInterface;
+use Drupal\Core\KeyValueStore\KeyValueMemoryFactory;
+use Drupal\Core\State\State;
+use Drupal\Tests\UnitTestCase;
+use Drupal\TestTools\Random;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Config\Checkpoint\CheckpointStorage
+ * @group Config
+ */
+class CheckpointStorageTest extends UnitTestCase {
+
+  use StorageCopyTrait;
+
+  /**
+   * The memory storage containing the data.
+   *
+   * @var \Drupal\Core\Config\MemoryStorage
+   */
+  protected MemoryStorage $memory;
+
+  /**
+   * The checkpoint storage under test.
+   *
+   * @var \Drupal\Core\Config\Checkpoint\CheckpointStorage
+   */
+  protected CheckpointStorage $storage;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+
+    // Set up a memory storage we can manipulate to set fixtures.
+    $this->memory = new MemoryStorage();
+    $keyValueMemoryFactory = new KeyValueMemoryFactory();
+    $state = new State($keyValueMemoryFactory);
+    $time = new Time();
+    $checkpoints = new Checkpoints($state, $time);
+    $this->storage = new CheckpointStorage($this->memory, $checkpoints, $keyValueMemoryFactory);
+  }
+
+  /**
+   * @covers ::checkpoint
+   * @covers \Drupal\Core\Config\Checkpoint\Checkpoint
+   */
+  public function testCheckpointCreation(): void {
+    $checkpoint = $this->storage->checkpoint('Test');
+    $this->assertInstanceOf(Checkpoint::class, $checkpoint);
+    $this->assertSame('Test', $checkpoint->label);
+
+    $checkpoint2 = $this->storage->checkpoint('This will not make a checkpoint because nothing has changed');
+    $this->assertSame($checkpoint2, $checkpoint);
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn([]);
+    $config->getRawData()->willReturn(['foo' => 'bar']);
+    $config->getStorage()->willReturn($this->storage);
+    $event = new ConfigCrudEvent($config->reveal());
+    $this->storage->onConfigSaveAndDelete($event);
+
+    $checkpoint3 = $this->storage->checkpoint('Created test.config');
+    $this->assertNotSame($checkpoint3, $checkpoint);
+    $this->assertSame('Created test.config', $checkpoint3->label);
+
+    $checkpoint4 = $this->storage->checkpoint('This will not create a checkpoint either');
+    $this->assertSame($checkpoint4, $checkpoint3);
+
+    // Simulate a save with no change.
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn(['foo' => 'bar']);
+    $config->getRawData()->willReturn(['foo' => 'bar']);
+    $config->getStorage()->willReturn($this->storage);
+    $event = new ConfigCrudEvent($config->reveal());
+    $this->storage->onConfigSaveAndDelete($event);
+
+    $checkpoint5 = $this->storage->checkpoint('Save with no change');
+    $this->assertSame($checkpoint5, $checkpoint3);
+
+    // Create collection and ensure that checkpoints are kept in sync.
+    $collection = $this->storage->createCollection('test');
+    $config = $this->prophesize(Config::class);
+    $config->getName()->willReturn('test.config');
+    $config->getOriginal('', FALSE)->willReturn(['foo' => 'bar']);
+    $config->getRawData()->willReturn(['foo' => 'collection_bar']);
+    $config->getStorage()->willReturn($collection);
+    $event = new ConfigCrudEvent($config->reveal());
+    $collection->onConfigSaveAndDelete($event);
+
+    $checkpoint6 = $this->storage->checkpoint('Save in collection');
+    $this->assertNotSame($checkpoint6, $checkpoint3);
+    $this->assertSame($collection->checkpoint('Calling checkpoint on collection'), $checkpoint6);
+  }
+
+  /**
+   * @covers ::exists
+   * @covers ::read
+   * @covers ::readMultiple
+   * @covers ::listAll
+   *
+   * @dataProvider readMethodsProvider
+   */
+  public function testReadOperations(string $method, array $arguments, array $fixture): void {
+    // Create a checkpoint so the checkpoint storage can be read from.
+    $this->storage->checkpoint('');
+    $this->setRandomFixtureConfig($fixture);
+
+    $expected = call_user_func_array([$this->memory, $method], $arguments);
+    $actual = call_user_func_array([$this->storage, $method], $arguments);
+    $this->assertEquals($expected, $actual);
+  }
+
+  /**
+   * Provide the methods that work transparently.
+   *
+   * @return array
+   *   The data.
+   */
+  public function readMethodsProvider(): array {
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => ['config.a', 'config.b', 'other.a'],
+    ];
+
+    $data = [];
+    $data[] = ['exists', ['config.a'], $fixture];
+    $data[] = ['exists', ['not.existing'], $fixture];
+    $data[] = ['read', ['config.a'], $fixture];
+    $data[] = ['read', ['not.existing'], $fixture];
+    $data[] = ['readMultiple', [['config.a', 'config.b', 'not']], $fixture];
+    $data[] = ['listAll', [''], $fixture];
+    $data[] = ['listAll', ['config'], $fixture];
+    $data[] = ['listAll', ['none'], $fixture];
+
+    return $data;
+  }
+
+  /**
+   * @covers ::write
+   * @covers ::delete
+   * @covers ::rename
+   * @covers ::deleteAll
+   *
+   * @dataProvider writeMethodsProvider
+   */
+  public function testWriteOperations(string $method, array $arguments, array $fixture): void {
+    $this->setRandomFixtureConfig($fixture);
+
+    // Create an independent memory storage as a backup.
+    $backup = new MemoryStorage();
+    static::replaceStorageContents($this->memory, $backup);
+
+    try {
+      call_user_func_array([$this->storage, $method], $arguments);
+      $this->fail("exception not thrown");
+    }
+    catch (\BadMethodCallException $exception) {
+      $this->assertEquals(CheckpointStorage::class . '::' . $method . ' is not allowed on a CheckpointStorage', $exception->getMessage());
+    }
+
+    // Assert that the memory storage has not been altered.
+    $this->assertEquals($backup, $this->memory);
+  }
+
+  /**
+   * Provide the methods that throw an exception.
+   *
+   * @return array
+   *   The data
+   */
+  public static function writeMethodsProvider(): array {
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => ['config.a', 'config.b'],
+    ];
+
+    $data = [];
+    $data[] = ['write', ['config.a', (array) Random::getGenerator()->object()], $fixture];
+    $data[] = ['write', [Random::MachineName(), (array) Random::getGenerator()->object()], $fixture];
+    $data[] = ['delete', ['config.a'], $fixture];
+    $data[] = ['delete', [Random::MachineName()], $fixture];
+    $data[] = ['rename', ['config.a', 'config.b'], $fixture];
+    $data[] = ['rename', ['config.a', Random::MachineName()], $fixture];
+    $data[] = ['rename', [Random::MachineName(), Random::MachineName()], $fixture];
+    $data[] = ['deleteAll', [''], $fixture];
+    $data[] = ['deleteAll', ['config'], $fixture];
+    $data[] = ['deleteAll', ['other'], $fixture];
+
+    return $data;
+  }
+
+  /**
+   * @covers ::getAllCollectionNames
+   * @covers ::getCollectionName
+   * @covers ::createCollection
+   */
+  public function testCollections(): void {
+    // Create a checkpoint so the checkpoint storage can be read from.
+    $this->storage->checkpoint('');
+    $fixture = [
+      StorageInterface::DEFAULT_COLLECTION => [$this->randomMachineName()],
+      'A' => [$this->randomMachineName()],
+      'B' => [$this->randomMachineName()],
+      'C' => [$this->randomMachineName()],
+    ];
+    $this->setRandomFixtureConfig($fixture);
+
+    $this->assertEquals(['A', 'B', 'C'], $this->storage->getAllCollectionNames());
+    foreach (array_keys($fixture) as $collection) {
+      $storage = $this->storage->createCollection($collection);
+      // Assert that the collection storage is still a checkpoint storage.
+      $this->assertInstanceOf(CheckpointStorage::class, $storage);
+      $this->assertEquals($collection, $storage->getCollectionName());
+    }
+  }
+
+  /**
+   * @covers ::encode
+   * @covers ::decode
+   */
+  public function testEncodeDecode(): void {
+    $array = (array) $this->getRandomGenerator()->object();
+    $string = $this->getRandomGenerator()->string();
+
+    // Assert reversibility of encoding and decoding.
+    $this->assertEquals($array, $this->storage->decode($this->storage->encode($array)));
+    $this->assertEquals($string, $this->storage->encode($this->storage->decode($string)));
+    // Assert same results as the decorated storage.
+    $this->assertEquals($this->memory->encode($array), $this->storage->encode($array));
+    $this->assertEquals($this->memory->decode($string), $this->storage->decode($string));
+  }
+
+  /**
+   * Generate random config in the memory storage.
+   *
+   * @param array $config
+   *   The config keys, keyed by the collection.
+   */
+  protected function setRandomFixtureConfig(array $config): void {
+    // Erase previous fixture.
+    foreach (array_merge([StorageInterface::DEFAULT_COLLECTION], $this->memory->getAllCollectionNames()) as $collection) {
+      $this->memory->createCollection($collection)->deleteAll();
+    }
+
+    foreach ($config as $collection => $keys) {
+      $storage = $this->memory->createCollection($collection);
+      foreach ($keys as $key) {
+        // Create some random config.
+        $storage->write($key, (array) $this->getRandomGenerator()->object());
+      }
+    }
+  }
+
+}
diff --git a/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointsTest.php b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointsTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..0940000c0efb3a319c18bf6dc969fd7e9a794056
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Config/Checkpoint/CheckpointsTest.php
@@ -0,0 +1,213 @@
+<?php
+
+namespace Drupal\Tests\Core\Config\Checkpoint;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Component\Render\FormattableMarkup;
+use Drupal\Core\Config\Checkpoint\Checkpoint;
+use Drupal\Core\Config\Checkpoint\CheckpointExistsException;
+use Drupal\Core\Config\Checkpoint\CheckpointNotExistsException;
+use Drupal\Core\Config\Checkpoint\Checkpoints;
+use Drupal\Core\State\StateInterface;
+use Drupal\Tests\UnitTestCase;
+use Prophecy\Argument;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Config\Checkpoint\Checkpoints
+ * @group Config
+ */
+class CheckpointsTest extends UnitTestCase {
+
+  /**
+   * The key used store of all the checkpoint names in state.
+   *
+   * @see \Drupal\Core\Config\Checkpoint\Checkpoints::CHECKPOINT_KEY
+   */
+  private const CHECKPOINT_KEY = 'config.checkpoints';
+
+  /**
+   * @covers ::add
+   * @covers ::count
+   * @covers ::getActiveCheckpoint
+   * @covers \Drupal\Core\Config\Checkpoint\Checkpoint
+   */
+  public function testAdd(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $state->set(self::CHECKPOINT_KEY, Argument::any())->willReturn(NULL);
+    $time = $this->prophesize(TimeInterface::class);
+    $time->getCurrentTime()->willReturn(1701539520, 1701539994);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $this->assertCount(0, $checkpoints);
+    $this->assertNull($checkpoints->getActiveCheckpoint());
+
+    $checkpoint = $checkpoints->add('hash1', 'Label');
+
+    $this->assertSame('hash1', $checkpoint->id);
+    $this->assertSame('Label', $checkpoint->label);
+    $this->assertNull($checkpoint->parent);
+    $this->assertSame(1701539520, $checkpoint->timestamp);
+
+    $this->assertCount(1, $checkpoints);
+    $this->assertSame('hash1', $checkpoints->getActiveCheckpoint()?->id);
+
+    // Test that on the second call to add the ancestor is set correctly.
+    $checkpoint2 = $checkpoints->add('hash2', new FormattableMarkup('Another label', []));
+    $this->assertSame('hash2', $checkpoint2->id);
+    $this->assertSame('Another label', (string) $checkpoint2->label);
+    $this->assertSame($checkpoint->id, $checkpoint2->parent);
+    $this->assertSame(1701539994, $checkpoint2->timestamp);
+
+    $this->assertCount(2, $checkpoints);
+    $this->assertSame('hash2', $checkpoints->getActiveCheckpoint()?->id);
+
+    // Test that the checkpoints object can be iterated over.
+    $i = 0;
+    foreach ($checkpoints as $value) {
+      $i++;
+      $this->assertInstanceOf(Checkpoint::class, $value);
+      $this->assertSame('hash' . $i, $value->id);
+    }
+  }
+
+  /**
+   * @covers ::add
+   */
+  public function testAddException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $state->set(self::CHECKPOINT_KEY, Argument::any())->willReturn(NULL);
+    $time = $this->prophesize(TimeInterface::class);
+    $time->getCurrentTime()->willReturn(1701539520, 1701539994);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+    $checkpoints->add('hash1', 'Label');
+    // Add another checkpoint with the same ID and an exception should be
+    // triggered.
+    $this->expectException(CheckpointExistsException::class);
+    $this->expectExceptionMessage('Cannot create a checkpoint with the ID "hash1" as it already exists');
+    $checkpoints->add('hash1', 'Label');
+  }
+
+  /**
+   * @covers ::getCheckpointsToReadFrom
+   * @covers ::setReadFromCheckpoint
+   */
+  public function testReadFromCheckpoint(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ]);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $read_checkpoints = iterator_to_array($checkpoints->getCheckpointsToReadFrom());
+    $this->assertCount(3, $read_checkpoints);
+    $this->assertSame(['hash1', 'hash2', 'hash3'], array_keys($read_checkpoints));
+
+    $checkpoints->setReadFromCheckpoint('hash2');
+    $read_checkpoints = iterator_to_array($checkpoints->getCheckpointsToReadFrom());
+    $this->assertCount(2, $read_checkpoints);
+    $this->assertSame(['hash2', 'hash3'], array_keys($read_checkpoints));
+
+    $checkpoints->setReadFromCheckpoint($read_checkpoints['hash3']);
+    $read_checkpoints = iterator_to_array($checkpoints->getCheckpointsToReadFrom());
+    $this->assertCount(1, $read_checkpoints);
+    $this->assertSame(['hash3'], array_keys($read_checkpoints));
+  }
+
+  /**
+   * @covers ::setReadFromCheckpoint
+   */
+  public function testReadFromCheckpointException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ]);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $this->expectException(CheckpointNotExistsException::class);
+    $this->expectExceptionMessage('The checkpoint "foo" does not exist');
+    $checkpoints->setReadFromCheckpoint('foo');
+  }
+
+  /**
+   * @covers ::setReadFromCheckpoint
+   */
+  public function testReadFromCheckpointEmpty(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+    $this->assertCount(0, iterator_to_array($checkpoints->getCheckpointsToReadFrom()));
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDeleteAll(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ]);
+    $state->delete(self::CHECKPOINT_KEY)->willReturn();
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $this->assertCount(3, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()->id);
+    $this->assertCount(3, iterator_to_array($checkpoints->getCheckpointsToReadFrom()));
+    $checkpoints->delete();
+    $this->assertCount(0, $checkpoints);
+    $this->assertNull($checkpoints->getActiveCheckpoint());
+    $this->assertCount(0, iterator_to_array($checkpoints->getCheckpointsToReadFrom()));
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDelete(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $test_data = [
+      'hash1' => new Checkpoint('hash1', 'One', 1701539510, NULL),
+      'hash2' => new Checkpoint('hash2', 'Two', 1701539520, 'hash1'),
+      'hash3' => new Checkpoint('hash3', 'Three', 1701539530, 'hash2'),
+    ];
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn($test_data);
+    unset($test_data['hash1'], $test_data['hash2']);
+    $state->set(self::CHECKPOINT_KEY, $test_data)->willReturn();
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $this->assertCount(3, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()->id);
+    $this->assertCount(3, iterator_to_array($checkpoints->getCheckpointsToReadFrom()));
+    $checkpoints->delete('hash2');
+    $this->assertCount(1, $checkpoints);
+    $this->assertSame('hash3', $checkpoints->getActiveCheckpoint()->id);
+    $this->assertCount(1, iterator_to_array($checkpoints->getCheckpointsToReadFrom()));
+  }
+
+  /**
+   * @covers ::delete
+   */
+  public function testDeleteException(): void {
+    $state = $this->prophesize(StateInterface::class);
+    $state->get(self::CHECKPOINT_KEY, [])->willReturn([]);
+    $time = $this->prophesize(TimeInterface::class);
+    $checkpoints = new Checkpoints($state->reveal(), $time->reveal());
+
+    $this->expectException(CheckpointNotExistsException::class);
+    $this->expectExceptionMessage('Cannot delete a checkpoint with the ID "foo" as it does not exist');
+
+    $checkpoints->delete('foo');
+  }
+
+}
